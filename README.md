# Elice Frontend Team PA (과목페이지 + API)

[목차]

[1. 개요](#개요) <br />
[2. 문제 파악 및 설계](#문제-파악-및-설계) <br />
[3. 활용한 라이브러리와 선택 이유](#활용한-라이브러리와-선택-이유)<br />
[4. 필터링 영역](#필터링-영역)<br />
[5. 카드 영역](#card-영역)<br />

## 개요

문제를 파악하고 설계하면서 로직 짜고 라이브러리를 선택한 이유에 대한 내용이 기록된 README.md 입니다. <br />
과거에 생각 한 내용들을 모두 정리하고 설명 하기 위해 작성 하였습니다. <br />

## 문제 파악 및 설계

문제는 전체적으로 유저가 선택한 내용에 따라 필터링을 할 수 있도록 해야하며 입력에 따라 자동으로 서버에 요청을 보내도록 해야하는 것으로 파악 했습니다. 파악한 내용을 바탕으로 순서도를 세우면

1. 사용자가 접속 했을 때 주소에 쿼리가 있는지 체크 합니다.
2. 어떤 데이터를 가져와야 하는지 판별합니다.
3. 가져온 데이터를 화면에 출력합니다.
4. 사용자가 필터를 선택하거나 input 태그에 검색할 키워드를 입력하면 쿼리에 추가하고 가져올 데이터를 판별하여 데이터를 페칭 하도록 합니다.
5. 가져온 데이터를 화면에 출력합니다.

생각한 순서도를 바탕으로 컴포넌트를 구성하였습니다.

처음 생각한 방식으로는 크게 두개의 컴포넌트로 나누어야 한다고 생각했습니다.<br />
두개의 컴포넌트는 아래와 같습니다.

1. 검색 input 태그를 포함한 필터링 버튼 영역 (이하 필터링 영역)
2. Card들이 나오는 영역 (이하 Card 영역)

두개로 나눠서 생각한 이유는 필터링 영역은 데이터 Fetching과는 상관 없으며 Card 부분은 Fetching을 계속 하고 있기 때문이었습니다. 그리고 필터링 영역에서 유저와 상호작용을 하게 되면 Card 부분이 영향을 받아서 작업을 해야하기 때문에 컴포넌트로 나누는 것이 좋겠다고 생각했습니다.<br />

그렇기 때문에 처음에는 두개의 컴포넌트를 완전 별도의 컴포넌트로 만들고 input 태그와 여러 버튼들을 눌렀을 때 주소에 저장하고 (어차피 새로고침을 했을 때를 위해 주소에 저장해야 하는 김에) Card 영역에서는 주소가 바뀌면 데이터 fetching을 시도 하려고 했습니다.

필터링 영역에서 주소에 쿼리를 저장한 이후에 Card 영역을 만들려고 하였습니다. Card 영역에서 주소를 불러오고 주소가 변했는지 확인하고 데이터를 fetching 하는 과정이 추가 되어야 했습니다. 해당 과정이 생각보다 리소스를 많이 잡아 먹을 것이고 불필요 하다고 판단했습니다.

결국 Card 영역은 필터링 영역의 자식으로 두고 상위에서 필터링과 관련된 데이터를 props로 받아와서 fetching 하는 편이 더 편할 것이라고 생각하였습니다.

설계를 하면서 라이브러리는 어떤 것들을 사용할까 고민 하였습니다.

## 활용한 라이브러리와 선택 이유

활용한 라이브러리는 아래와 같습니다.

1. Next.js
2. Tanstack-query
3. lodash
4. Tailwind CSS
5. react-hook-form
6. react-error-boundary

그 외에 디자인을 위해 shadcn-ui를 사용하였으며 해당 디자인 시스템을 사용하기 위해 clsx와 cva, tailwind-merge가 같이 설치 되었습니다.

- Next.js는 기본적으로 문제에서 요구하였기 때문에 선택하였습니다.
- Tanstack-query를 사용하면 서버에서 데이터를 가져오는 상태를 관리하기 쉽습니다. 그리고 query 키를 활용한 데이터 캐싱과 Suspense, ErrorBoundrary를 지원하고 쉽게 대응 할 수 있기 때문에 비동기 통신을 지원하는 Redux나 기타 다른 상태관리 라이브러리에 비해 장점이 있다고 생각해서 활용하였습니다.
- lodash의 경우 input 태그에서 입력이 발생 했을 때 마다 서버에 데이터를 보내는 것을 막기 위해 사용하였습니다.
- Tailwind CSS는 비교적 최근까지 활용해왔고 현재에는 가장 익숙한 디자인 관련 라이브러리이기 때문에 사용 했습니다. 또한 빌드 후 CSS 파일로 나오기 때문에 Next.js와의 궁합이 잘 맞다고 생각합니다.
- react-hook-form 사용해야 할 input과 필터 버튼들이 많기 때문에 별도의 state로 관리 하기보다는 react-hook-form을 통해 한꺼번에 관리 하는 것이 편하다고 생각하여서 사용하였습니다.
- react-error-boundary 기존 공식 홈페이지에 소개된 error boundary와 거의 동일한 기능을 수행 하면서도 함수형으로 작성되어 있으며 props로 여러 fallback 컴포넌트를 받을 수 있기 때문에 페이지 별로 별도의 에러 컴포넌트를 작성할 수 있다는 이점이 있어서 사용하였습니다.

## 필터링 영역

필터링 영역에서는 제목 검색을 위한 input 태그와 여러 버튼들이 존재하는 컴포넌트 입니다.

해당 컴포넌트에서 검색을 제외한 나머지 Chip 버튼들은 테이블로 만드는 편이 훨씬 효율적이라고 생각했습니다.

그리고 각 버튼의 내용들을 백엔드 서버에서 가져오는지 확인 할 수 없었기 때문에 constant 폴더에 별도의 객체로 관리하는 편이 좋겠다고 생각하여 객체로 관리하게 했습니다.

처음에는 주소에 쿼리로 저장할 생각으로 간단하게 만들었으나 이후에 서버에서 가져오는 값을 확인하여 객체를 다시 변경하였습니다.

마지막으로 서버에 요청할 쿼리문을 만들기 위해 form을 통해 만들어낸 데이터를 분별하고 조작하기 위한 함수를 lib/dataProcessing.ts 파일에 만들었습니다. 해당 함수를 통해 form에 어떤 데이터를 유저가 선택했는지 확인하고 정리한 결과를 JSON 구조로 만들기 위한 전처리를 하게 됩니다.

## Card 영역

카드 영역에서는 필터링 영역의 결과를 바탕으로 데이터를 fetching 하고 화면에 출력하도록 합니다.

처음 offset은 0으로 지정하고 필터의 내용이 바뀌면 1페이지로 올 수 있도록 다시 0으로 바뀌도록 하였습니다.

데이터를 페칭할 때 queryKey로 filter의 데이터와 offset을 넣어주었습니다. 페이지에 따라서 그리고 데이터에 따라서 페칭해와야 하기 때문입니다.

페이지네이션을 위한 로직이 들어가 있습니다.

해당 로직은 /app/(components)/(CardContent)/Pagination.tsx에 들어있습니다.

실제로 서비스 되고 있는 페이지를 살펴본 결과 총 페이지가 5페이지가 넘어가며 현재 페이지가 2페이지 이하인 경우 페이지네이션 버튼은 5개로 고정되는 것을 확인하고 해당 기능과 최대한 유사하게 만들었습니다. (반대도 마찬가지 입니다.)

10페이지 이상인 경우 처음 상태는 1부터 9까지 있으며 중앙을 기준으로 이전으로는 -4 만큼 이후로는 +4만큼 되도록 하였습니다.
